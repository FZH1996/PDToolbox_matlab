% example of a game with one population, three strategies per population, and combined dynamics.

path(path, '../../revision_protocols')
path(path, '../../graphs')
path(path, '../../dynamics')
path(path, '../../')


% TODO:
% review how are the transitions between dynamics
% review why rd and logit are so similar in aggregated evolution, but
% differents in incentives


% population games tool box
clear

global G


global beta_ef alpha_ef time_on time_off mp N T_ hybrid

N = 5;

% Definition of the electricity variables
Dt = 15*[51.8743   50.0011   48.6104    48.6384    51.1276    58.7756 ...
    61.0654   65.0167   69.6593    71.6363    75.3904    76.2807 ...
    73.4635   73.3627   74.6492    75.1194    74.8689    74.1951 ...
    78.2569   85.8935   83.5392    77.9073    68.6800   60.5177];
pt = Dt./max(Dt)*8;

T_ = length(Dt);

alpha_ef = zeros(N,T_);
% valuation parameters of all agents
for i=1:N
    alpha_ef(i,:) = pt(1:T_)*(1+.5*i/N) + 0. *rand(1,T_);
end

% parametros de la func. de costo agregado
beta_ef = 1;

% Time of the activation of either incentives or attacks
time_on = 2;
time_off = 4;









% number of populations
P = 5;

% number of pure strategies per population
n = 25;

mp = 30;
m = ones(P, 1) * mp;

% simulation parameters
time = 20;

pot_r = ones(N,T_+1)/(T_+1);
x0 = pot_r';

% structure with the parameters of the game
G = struct('P', P, 'n', n, 'f', @fitness_user, 'ode', 'ode113', 'time', time, 'step', 0.00001, 'x0', x0, 'm', m);

% random initial condition
%G = struct('P', P, 'n', n, 'f', @fitness_user, 'ode', 'ode23s', 'time', time, 'step', 0.00001);

% verify data of the game
G = definition(G);


G.step = .01;

G.eta = .02;
% run different dynamics
G.dynamics = {'rd'};
G.run()
T = G.T;
X_eff = G.X;

% extract matrix of strategies
x_n = vec2mat(X_eff(end, :), n);
x_eff = zeros(G.P, n);

for p = 1 : G.P
    x_eff(p, :) = x_n(p, :) * G.m(p);
end

U_eff = utility(x_eff);



G.f = @fitness_user_inefficient;
G.run()
X_ineff = G.X;


% extract matrix of strategies
x_n = vec2mat(X_ineff(end, :), n);
x_ineff = zeros(G.P, n);

for p = 1 : G.P
    x_ineff(p, :) = x_n(p, :) * G.m(p);
end

U_ineff = utility(x_ineff);


%figure(3); plot(1:1:24, U(:, 1:24))
%figure(4); plot(1:1:24, x(:, 1:24))


figure(5)
clf
hold on
plot(1:1:24, sum(U_eff(:, 1:24)))
plot(1:1:24, sum(U_ineff(:, 1:24)), '--k')

title('Total Society`s Surplus')
%ylim([min(U_ineff)*.9 max(U_eff)*1.1])
xlim([1) T(end)])
ylabel('Social Surplus')
xlabel('Hour')


h = legend( 'Optimal outcome (Pareto)', 'Suboptimal outcome (Nash equilibrium)',4);
set(h,'Interpreter','none')


